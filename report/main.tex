\documentclass[colorback,accentcolor=tud1c,11pt]{tudreport}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
%\usepackage[T1]{fontenc}

%\usepackage[stable]{footmisc}
%\usepackage[ngerman,pdfview=FitH,pdfstartview=FitV]{hyperref}

\usepackage{booktabs}
%\usepackage{multirow}
%\usepackage{longtable}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{subfigure} 	
\usepackage{float}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{wrapfig}

\newcommand\todo[1]{\textcolor{red}{#1}}
\newcommand\code[1]{\texttt{#1}}
%\usepackage{floatflt}

\graphicspath{{./img/}}

%\newlength{\longtablewidth}
%\setlength{\longtablewidth}{0.675\linewidth}

\title{Mini-task report: FlowMap Lut-Packing Algorithm}
\subtitle{Ludwig Meysel, Mitja Stachowiak}

\begin{document}
\maketitle



\chapter{Introduction}
The task was to implement a simple version of the Flow Map algorithm which is used to bring arbitrary boolean functions and - networks to PCBs with limited size of lookup tables.



\chapter{BLIF Parser}
The Parser of the Espresso-project is used again and developed further; especially the functions are now stored in a graph-structure. It is still ready-to-use for the Espresso-package. The parser now also supports latches and sub-circuits in a basically way that enables it to hold this information in memory and save it back to file.

The Graph is provided via the GraphNode-interface. This consists of a list of input nodes, a set of output nodes and a name. The name is not necessarily unique in one model: In the BLIF-Fileformat, the model's outputs can be manually specified. It is therefore possible to have a functional tree, which is not used by any successor component. Such unused paths should be eliminated by a good optimization but the parser sould be able to read and write even such unused paths. To store the list of used outputs, it is a goot idea to create a special OutputNode-Type. This output automaticcally use the same name as the predecessor-node, that they belong to. Otherwise a name-string must be generated which was of no relevance for the BLIF-format. Finally it can be said, that a GraphNode is clearly specified by it's node type (class) and it's string name.

The graph-tree is meant to be modified by the node's inputs (predecesssors) while the outputs (successors) are readonly for most packages. The implementations of the GraphNode-interface use instances of the in-list that are self-linking, which means a command node1.in().set(0, node2); will remove node1 from the out-set of node1.in[0] and add node1 to the out-set of node2. The out-sets are initialized with special HashSets, that throw exceptions when calling modifying functions like out().add() or out().remove(). Only the self-linking-lists have write access to the out-sets.

Sub-circuits are no GraphNodes, because a GraphNode only has one output literal (which can of-curse be used by several successors, stored in the out-set). A Sub-circuit can have multiple outputs and each of them could have multiple successors. So the sub-circuits inputs and outputs are realized as GraphNodes and the sub-circuit appears in the graph-tree like a set of general model's inputs and outputs. So it is not possible, to compose logic across model corners. A function, that inserts the sub-circuit's logic into the parent model is required therefore.

In general, the graph implementation of the BLIF-structure is kept simple and small for not overcharging other projects (like Espresso) which don't need the graph-functionalities. The graph processing functionality of models and functions is realized in inherited classes GraphModel and GraphFunction. The programmer needs to give factories for this class-types to the BLIF-parser for the FlowMap-project.



\chapter{Decomposition}
\begin{wrapfigure}{r}{0.41\textwidth}
\centering
\includegraphics[width=0.4\textwidth]{img/Decompose1.pdf}\\
\caption{Example of redundant decomposition}
\label{fig:decompose1}
\end{wrapfigure}
The decomposition's task is to split each function, that has more than two inputs. It is an arbitrary complex problem to decide, which tree of two-input functions is the smalles/best representation of the model. But for FlowMap, the problem is much simpler: There is never a xor-gate or something like that extracted out of a multi-input function for decomposition. The function is regarded to be a set of and-gates, which are finally connected by one or-gate. On this structure, simple gate-level decomposition is done. The result may not be the smallest or fastest possible tree of two-input functions, but the composition-algorithm will later put possibly inefficiently splitted function-parts in the same lookup-table again.

A problem can result from redundant functions. A decomposition like in \ref{fig:decompose1} can easily result from a BLIF, that describes each of the outputs in one boolean function. The composition with three inputs would result in four lookup tables, while the and-tree is redundant. When setting reUseExistingFunctions to true, the decomposition don't re-create functions with equal inputs and functionality. It can also be seen, that decomposition in a different order can create a structure, where the and-gates are non-redundant regarding the graph structure. An advanced concept of removing redundant structures was not task of this project and could be verry difficult. The reUseExistingFunctions only finds a few gates, that can be re-used.



\include{labelling}



\chapter{Composition}




\chapter{Conclusion}
Niemand interessiert die Conclusion   :P
\\
The project is realized in about ???? lines of code.



\bibliographystyle{plain}
\bibliography{references}

\end{document}

